
buildscript {
	repositories { mavenCentral() }
	dependencies {
		classpath 'org.eclipse.jgit:org.eclipse.jgit:2.+'
		classpath 'org.eclipse.mylyn.github:org.eclipse.egit.github.core:1.+'
		[
			'jersey-core',
			'jersey-client'
		].each { classpath "com.sun.jersey:$it:1.+" }
	}
}

def startUpRoot = project.file("$buildDir/yuzenstartups")
task makeStartUpFiles(type: org.gradle.api.tasks.wrapper.Wrapper) {
	scriptFile = "$startUpRoot/gradlew"
	jarFile = "$startUpRoot/gradle/wrapper/gradle-wrapper.jar"
	doLast {
		File build = new File(startUpRoot, 'build.gradle')
		build.text = '''apply from:"http://yuzen.koshinuke.org/install"

site {
	//head = 'less'
	feed {
		syndicationURI = 'http://example.org'
		author = 'john doe'
	}
}
github {
	projectURI = 'https://github.com/[your github account]/[your repository name]'
}
yuzen.publish {
	ghpages	repoURI : "${project.github.projectURI}.git"
}
'''
		File gprops = new File(startUpRoot, 'gradle.properties')
		gprops.text = '''
github.username=john
github.password=doe

#systemProp.http.proxyHost=example.com
#systemProp.http.proxyPort=8080
#systemProp.https.proxyHost=example.com
#systemProp.https.proxyPort=8080
'''
		File ignore = new File(startUpRoot, '.gitignore')
		ignore.text = '''/.*
!/.git*
/build
/gradle.*
'''
	}
}

task makeStartUpArchive(dependsOn: makeStartUpFiles, type: Zip) {
	archiveName = 'yuzen-startup.zip'
	from(startUpRoot)
	destinationDir = getTemporaryDir()
	doFirst {
		PatternSet.setGlobalExcludes([])
	}
	doLast {
		PatternSet.resetGlobalExcludes()
	}
}

task uploadStartUpArchive(dependsOn: makeStartUpArchive) << {
	def client = new GitHubClient()
	client.setCredentials(project['github.username'], project['github.password'])
	def repoid = RepositoryId.create('taichi', 'yuzen')
	def dls = new DownloadService(client)
	def d = new Download()
	d.name = makeStartUpArchive.archiveName
	def ps = makeStartUpArchive.rootSpec.patternSet
	dls.createDownload(repoid, d, makeStartUpArchive.archivePath)
}

task stage_list(type: StagingListTask)
task stage_close(type: StagingCloseTask) { repositoryId = getInput('repoId') }
task stage_drop(type: StagingDropTask) { repositoryId = getInput('repoId') }

task release(dependsOn: uploadArchives, type: AutoReleaseTask)

import groovy.json.JsonBuilder
import groovy.json.JsonSlurper

import javax.ws.rs.core.MediaType

import org.eclipse.egit.github.core.Download
import org.eclipse.egit.github.core.RepositoryId
import org.eclipse.egit.github.core.client.GitHubClient
import org.eclipse.egit.github.core.service.DownloadService
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.errors.UnsupportedCredentialItem
import org.eclipse.jgit.lib.TextProgressMonitor
import org.eclipse.jgit.transport.CredentialItem
import org.eclipse.jgit.transport.CredentialsProvider;
import org.eclipse.jgit.transport.URIish;
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.bundling.Zip
import org.gradle.api.tasks.util.PatternSet

import com.sun.jersey.api.client.Client
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.config.ClientConfig
import com.sun.jersey.api.client.config.DefaultClientConfig
import com.sun.jersey.api.client.filter.HTTPBasicAuthFilter


// sonatype uploadArchives , verify , release / REST API ?
// http://www.sonatype.com/people/2012/07/nexus-pro-automating-staging-workflow-with-gradle-using-the-nexus-rest-apis/
// https://github.com/sonatype/nexus/blob/master/nexus-maven-plugins/nexus-maven-plugin/src/main/java/org/sonatype/nexus/plugin/staging/AbstractStagingMojo.java
// https://github.com/sonatype/nexus/blob/master/nexus/nexus-clients/nexus-restlight-clients/nexus-restlight-stage-client/src/main/java/org/sonatype/nexus/restlight/stage/StageClient.java
abstract class SonaTypeTask extends DefaultTask {
	def repo = 'https://oss.sonatype.org/'

	@Input
	def profileName = project.group

	@Input
	def username = project.sonatypeUsername

	@Input
	def password = project.sonatypePassword

	def getInput(name) {
		if(project.hasProperty(name)) {
			return project[name]
		}
		return null
	}

	def resource(path) {
		ClientConfig cc = new DefaultClientConfig()
		Client c = Client.create(cc)
		c.followRedirects = true
		c.addFilter(new HTTPBasicAuthFilter(username, password))
		return c.resource(repo).path(path).accept(MediaType.APPLICATION_JSON_TYPE)
	}

	def toJson(r) {
		r.withReader {
			return new JsonSlurper().parse(it)
		}
	}

	def get(path) {
		toJson(resource(path).get(Reader))
	}

	def post(path, data) {
		def json = new JsonBuilder()
		json.data data
		resource(path)
				.type(MediaType.APPLICATION_JSON_TYPE)
				.post(ClientResponse, json.toString())
	}

	def getProfiles() {
		get('service/local/staging/profiles')?.data.findAll { it.name == profileName }
	}

	def list() {
		get('service/local/staging/profile_repositories')?.data.findAll { it.profileName == profileName }
	}

	def close(ids) {
		post('service/local/staging/bulk/close', [stagedRepositoryIds: ids, description : ''])
	}
	
	def reportClose(resp) {
		if(resp.status < 300) {
			logger.lifecycle 'uploaded artifact is closed'
		} else if(500 <= resp.status) {
			logger.error resp.getEntity(String)
			throw new RuntimeException(resp.toString())
		} else {
			def j = toJson(resp.getEntity(Reader))
			if(j?.errors) {
				j.errors.each { logger.error "$it.id $it.msg" }
			}
			if(j?.failures) {
				logger.error "$j.repositoryName"
				j.failures.each {
					logger.error "\t$it.ruleName"
					it.messages.each { logger.error "\t\t$it" }
				}
			}
			throw new RuntimeException()
		}
	}
	
	def release(ids) {
		post("service/local/staging/bulk/promote", [stagedRepositoryIds: ids, description : ''])
	}

	def drop(ids) {
		post("service/local/staging/bulk/drop", [stagedRepositoryIds: ids, description : ''])
	}
}

class StagingListTask extends SonaTypeTask {
	@TaskAction
	def stage_list() {
		list().each {
			it.each { logger.lifecycle String.format('%-22s %s',it.key, it.value) }
			logger.lifecycle ""
		}
	}
}

class StagingCloseTask extends SonaTypeTask {
	@Input
	def repositoryId

	@TaskAction
	def stage_close() {
		reportClose close([repositoryId])
	}
}

class StagingDropTask extends SonaTypeTask {
	@Input
	def repositoryId

	@TaskAction
	def stage_drop() {
		def resp = drop([repositoryId])
		if(resp.status < 300) {
			logger.lifecycle 'drop succeed'
		} else {
			throw new RuntimeException(resp.toString())
		}
	}
}

class AutoReleaseTask extends SonaTypeTask {
	
	@TaskAction
	def autoRelease() {
		def repos = list().findAll { it.type == 'open' }
		if(repos.size() < 1) {
			throw new RuntimeException("no uploaded contents")
		}
		def r = selectRepo(repos)
		reportClose(close([r.repositoryId]))
		tagging()
		def resp = release([r.repositoryId])
		if(resp.status < 300) {
			logger.lifecycle 'release succeed'
		} else {
			throw new RuntimeException(resp.toString())
		}
	}
	
	def selectRepo(repos) {
		if(repos.size() == 1) {
			return repos[0]
		} else {
			return repos.sort { l, r -> r.createdTimestamp <=> l.createdTimestamp }[0]
		}
	}
	
	def tagging() {
		def g = Git.open file('.git')
		def tag = null
		try {
			def n = project.version
			tag = g.tag() setName n setMessage "release $n" call()
			// PassphrraseProvider read passphrase from gradle.properties ??
			g.push().setPushTags().setCredentialsProvider new PassphraseProvider(project['ssh.passphrase']) setProgressMonitor new TextProgressMonitor() call()
		} catch(e) {
			g.tagDelete().setTags(tag?.tagName).call()
			throw e
		} finally {
			g.repository.close()
		}
	}
}

class PassphraseProvider extends CredentialsProvider {
	def passphrase = ""
	PassphraseProvider(pass) {
		this.passphrase = pass
	}
	def boolean isInteractive() {
		false
	}
	def boolean supports(CredentialItem... items) {
		true
	}
	def boolean get(URIish uri, CredentialItem... items) {
		items.each {
			if(it instanceof CredentialItem.StringType) {
				it.value = passphrase
				return true
			} else {
				throw new UnsupportedCredentialItem(uri, it.promptText);
			}
		}
	}
}
